//Standard Libraries
import java.util.LinkedList;

//ANTLR runtime libraries:
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

//Driver for the parsing of Little language source.
public class Driver {

	public static void main(String[] args) throws Exception{
		
		try {
		
			//Creates an ANTLR character input stream from standard input (console).
			@SuppressWarnings("deprecation")
			ANTLRInputStream input = new ANTLRInputStream(System.in);
			
			//Creates a lexer object generated by ANTLR that recognizes and classifies the tokens specified by the Little.g4 file.
			LittleLexer lexer = new LittleLexer(input);
			
			//Removes the standard error handling (would recover on errors)
			lexer.removeErrorListeners();
			//Customer error handler throws an RuntimeException on error so scanning will stop and the program will exit.
			lexer.addErrorListener(new AnyErrorListener());
			
			//Converts lexer validated tokens to a stream of tokens as input to the parser stage.
			TokenStream tokens = new CommonTokenStream(lexer);
			
			//Creates a parser object generated by ANTLR for constructing a parse tree for a given input, given its tokens are valid.
			LittleParser parser = new LittleParser(tokens);
			
			//Removes the standard error handling (would recover on errors)
			parser.removeErrorListeners();
			//Customer error handler throws an RuntimeException on error so parsing will stop and the program will exit.
			parser.addErrorListener(new AnyErrorListener());
			
			//Starts parsing at the program rule. i.e. Start rule = program and ParseTree root = program.
			ParseTree tree = parser.program();
			
			//Generic parse tree walker used to trigger callbacks.
			ParseTreeWalker walker = new ParseTreeWalker();
			
			//The code generation object.
			CodeExtractor littleExtractor = new CodeExtractor();
			
			//A walker to perform a depth first walk of the parse tree, the CodeGenerator object will generate code.
			//from the tree to build a and IR and then tiny architecture assembly code.
			walker.walk(littleExtractor, tree);
			
			//Get the symbol table and AST from the parse tree walk.
			LinkedList<SymbolTable> symTabs = littleExtractor.getSymbolTables();
			AST ast = littleExtractor.getAST();
			
			//IR Code generator.
			CodeGenerator littleGenerator = new CodeGenerator(symTabs, ast);
			
			//Uses the symbols and the AST to generate IR Code from the high level language.
			littleGenerator.generateIR();

			//Tiny Assembly code generator.
			InstructionConverter tinyConverter = new InstructionConverter(littleGenerator.getIR());
			
			//Converts the internal IR Code into Tiny Assembly.
			tinyConverter.convertToAssembly();
			
			//Prints all the generated IR Code.
			System.out.println(";"+"IR Code");
			
			for(String irLine: littleGenerator.getIR()) {
				
				System.out.println(";"+irLine);
			}
			
			//Prints all the Tiny Assembly code.
			System.out.println(";"+"Tiny Code");
			
			for(String instruction: tinyConverter.getAssemblyCode()) {
				
				System.out.println(instruction);
			}
			
		// Catches any lexer, parser, or semantic errors.
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
}

//Class to change the standard ANTLR error handling, catches parser errors.
class AnyErrorListener extends BaseErrorListener{
	
	//Overrides the syntaxError method to throw an exception that is not caught by ANTLR and will be identified by the Driver class.
	@Override
	public void syntaxError(Recognizer<?,?> recognizer, Object offendingSymbol, int line, int charPositionLine, String msg, RecognitionException e){
		throw new RuntimeException(e);
	}
}
